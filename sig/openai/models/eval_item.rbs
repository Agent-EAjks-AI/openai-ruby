module OpenAI
  module Models
    type eval_item =
      {
        content: OpenAI::EvalItem::content,
        role: OpenAI::EvalItem::role,
        type: OpenAI::EvalItem::type_
      }

    class EvalItem < OpenAI::Internal::Type::BaseModel
      attr_accessor content: OpenAI::EvalItem::content

      attr_accessor role: OpenAI::EvalItem::role

      attr_reader type: OpenAI::EvalItem::type_?

      def type=: (OpenAI::EvalItem::type_) -> OpenAI::EvalItem::type_

      def initialize: (
        content: OpenAI::EvalItem::content,
        role: OpenAI::EvalItem::role,
        ?type: OpenAI::EvalItem::type_
      ) -> void

      type content =
        String
        | OpenAI::Responses::ResponseInputText
        | OpenAI::EvalItem::Content::OutputText

      module Content
        extend OpenAI::Internal::Type::Union

        type output_text = { text: String, type: :output_text }

        class OutputText < OpenAI::Internal::Type::BaseModel
          attr_accessor text: String

          attr_accessor type: :output_text

          def initialize: (text: String, ?type: :output_text) -> void
        end

        def self?.variants: -> ::Array[OpenAI::EvalItem::content]
      end

      type role = :user | :assistant | :system | :developer

      module Role
        extend OpenAI::Internal::Type::Enum

        USER: :user
        ASSISTANT: :assistant
        SYSTEM: :system
        DEVELOPER: :developer

        def self?.values: -> ::Array[OpenAI::EvalItem::role]
      end

      type type_ = :message

      module Type
        extend OpenAI::Internal::Type::Enum

        MESSAGE: :message

        def self?.values: -> ::Array[OpenAI::EvalItem::type_]
      end
    end
  end
end
