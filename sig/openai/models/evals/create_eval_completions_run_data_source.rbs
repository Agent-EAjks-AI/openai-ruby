module OpenAI
  module Models
    module Evals
      type create_eval_completions_run_data_source =
        {
          source: OpenAI::Evals::CreateEvalCompletionsRunDataSource::source,
          type: OpenAI::Evals::CreateEvalCompletionsRunDataSource::type_,
          input_messages: OpenAI::Evals::CreateEvalCompletionsRunDataSource::input_messages,
          model: String,
          sampling_params: OpenAI::Evals::CreateEvalCompletionsRunDataSource::SamplingParams
        }

      class CreateEvalCompletionsRunDataSource < OpenAI::Internal::Type::BaseModel
        attr_accessor source: OpenAI::Evals::CreateEvalCompletionsRunDataSource::source

        attr_accessor type: OpenAI::Evals::CreateEvalCompletionsRunDataSource::type_

        attr_reader input_messages: OpenAI::Evals::CreateEvalCompletionsRunDataSource::input_messages?

        def input_messages=: (
          OpenAI::Evals::CreateEvalCompletionsRunDataSource::input_messages
        ) -> OpenAI::Evals::CreateEvalCompletionsRunDataSource::input_messages

        attr_reader model: String?

        def model=: (String) -> String

        attr_reader sampling_params: OpenAI::Evals::CreateEvalCompletionsRunDataSource::SamplingParams?

        def sampling_params=: (
          OpenAI::Evals::CreateEvalCompletionsRunDataSource::SamplingParams
        ) -> OpenAI::Evals::CreateEvalCompletionsRunDataSource::SamplingParams

        def initialize: (
          source: OpenAI::Evals::CreateEvalCompletionsRunDataSource::source,
          type: OpenAI::Evals::CreateEvalCompletionsRunDataSource::type_,
          ?input_messages: OpenAI::Evals::CreateEvalCompletionsRunDataSource::input_messages,
          ?model: String,
          ?sampling_params: OpenAI::Evals::CreateEvalCompletionsRunDataSource::SamplingParams
        ) -> void

        type source =
          OpenAI::Evals::EvalJSONLFileContentSource
          | OpenAI::Evals::EvalJSONLFileIDSource
          | OpenAI::Evals::CreateEvalCompletionsRunDataSource::Source::StoredCompletions

        module Source
          extend OpenAI::Internal::Type::Union

          type stored_completions =
            {
              type: :stored_completions,
              created_after: Integer?,
              created_before: Integer?,
              limit: Integer?,
              metadata: OpenAI::Models::metadata?,
              model: String?
            }

          class StoredCompletions < OpenAI::Internal::Type::BaseModel
            attr_accessor type: :stored_completions

            attr_accessor created_after: Integer?

            attr_accessor created_before: Integer?

            attr_accessor limit: Integer?

            attr_accessor metadata: OpenAI::Models::metadata?

            attr_accessor model: String?

            def initialize: (
              ?created_after: Integer?,
              ?created_before: Integer?,
              ?limit: Integer?,
              ?metadata: OpenAI::Models::metadata?,
              ?model: String?,
              ?type: :stored_completions
            ) -> void
          end

          def self?.variants: -> ::Array[OpenAI::Evals::CreateEvalCompletionsRunDataSource::source]
        end

        type type_ = :completions

        module Type
          extend OpenAI::Internal::Type::Enum

          COMPLETIONS: :completions

          def self?.values: -> ::Array[OpenAI::Evals::CreateEvalCompletionsRunDataSource::type_]
        end

        type input_messages =
          OpenAI::Evals::CreateEvalCompletionsRunDataSource::InputMessages::Template
          | OpenAI::Evals::CreateEvalCompletionsRunDataSource::InputMessages::ItemReference

        module InputMessages
          extend OpenAI::Internal::Type::Union

          type template =
            {
              template: ::Array[OpenAI::Evals::CreateEvalCompletionsRunDataSource::InputMessages::Template::template],
              type: :template
            }

          class Template < OpenAI::Internal::Type::BaseModel
            attr_accessor template: ::Array[OpenAI::Evals::CreateEvalCompletionsRunDataSource::InputMessages::Template::template]

            attr_accessor type: :template

            def initialize: (
              template: ::Array[OpenAI::Evals::CreateEvalCompletionsRunDataSource::InputMessages::Template::template],
              ?type: :template
            ) -> void

            type template =
              OpenAI::Responses::EasyInputMessage | OpenAI::EvalItem

            module Template
              extend OpenAI::Internal::Type::Union

              def self?.variants: -> ::Array[OpenAI::Evals::CreateEvalCompletionsRunDataSource::InputMessages::Template::template]
            end
          end

          type item_reference =
            { item_reference: String, type: :item_reference }

          class ItemReference < OpenAI::Internal::Type::BaseModel
            attr_accessor item_reference: String

            attr_accessor type: :item_reference

            def initialize: (
              item_reference: String,
              ?type: :item_reference
            ) -> void
          end

          def self?.variants: -> ::Array[OpenAI::Evals::CreateEvalCompletionsRunDataSource::input_messages]
        end

        type sampling_params =
          {
            max_completion_tokens: Integer,
            seed: Integer,
            temperature: Float,
            top_p: Float
          }

        class SamplingParams < OpenAI::Internal::Type::BaseModel
          attr_reader max_completion_tokens: Integer?

          def max_completion_tokens=: (Integer) -> Integer

          attr_reader seed: Integer?

          def seed=: (Integer) -> Integer

          attr_reader temperature: Float?

          def temperature=: (Float) -> Float

          attr_reader top_p: Float?

          def top_p=: (Float) -> Float

          def initialize: (
            ?max_completion_tokens: Integer,
            ?seed: Integer,
            ?temperature: Float,
            ?top_p: Float
          ) -> void
        end
      end
    end
  end
end
