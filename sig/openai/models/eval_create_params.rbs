module OpenAI
  module Models
    type eval_create_params =
      {
        data_source_config: OpenAI::Models::EvalCreateParams::data_source_config,
        testing_criteria: ::Array[OpenAI::EvalCreateParams::testing_criterion],
        metadata: OpenAI::Models::metadata?,
        name: String
      }
      & OpenAI::Internal::Type::request_parameters

    class EvalCreateParams < OpenAI::Internal::Type::BaseModel
      extend OpenAI::Internal::Type::RequestParameters::Converter
      include OpenAI::Internal::Type::RequestParameters

      attr_accessor data_source_config: OpenAI::Models::EvalCreateParams::data_source_config

      attr_accessor testing_criteria: ::Array[OpenAI::EvalCreateParams::testing_criterion]

      attr_accessor metadata: OpenAI::Models::metadata?

      attr_reader name: String?

      def name=: (String) -> String

      def initialize: (
        data_source_config: OpenAI::Models::EvalCreateParams::data_source_config,
        testing_criteria: ::Array[OpenAI::EvalCreateParams::testing_criterion],
        ?metadata: OpenAI::Models::metadata?,
        ?name: String,
        ?request_options: OpenAI::request_opts
      ) -> void

      type data_source_config =
        OpenAI::EvalCreateParams::DataSourceConfig::Custom
        | OpenAI::EvalCreateParams::DataSourceConfig::Logs

      module DataSourceConfig
        extend OpenAI::Internal::Type::Union

        type custom =
          {
            item_schema: ::Hash[Symbol, top],
            type: :custom,
            include_sample_schema: bool
          }

        class Custom < OpenAI::Internal::Type::BaseModel
          attr_accessor item_schema: ::Hash[Symbol, top]

          attr_accessor type: :custom

          attr_reader include_sample_schema: bool?

          def include_sample_schema=: (bool) -> bool

          def initialize: (
            item_schema: ::Hash[Symbol, top],
            ?include_sample_schema: bool,
            ?type: :custom
          ) -> void
        end

        type logs = { type: :logs, metadata: ::Hash[Symbol, top] }

        class Logs < OpenAI::Internal::Type::BaseModel
          attr_accessor type: :logs

          attr_reader metadata: ::Hash[Symbol, top]?

          def metadata=: (::Hash[Symbol, top]) -> ::Hash[Symbol, top]

          def initialize: (?metadata: ::Hash[Symbol, top], ?type: :logs) -> void
        end

        def self?.variants: -> ::Array[OpenAI::Models::EvalCreateParams::data_source_config]
      end

      type testing_criterion =
        OpenAI::EvalCreateParams::TestingCriterion::LabelModel
        | OpenAI::EvalStringCheckGrader
        | OpenAI::EvalTextSimilarityGrader
        | OpenAI::EvalCreateParams::TestingCriterion::Python
        | OpenAI::EvalCreateParams::TestingCriterion::ScoreModel

      module TestingCriterion
        extend OpenAI::Internal::Type::Union

        type label_model =
          {
            input: ::Array[OpenAI::EvalCreateParams::TestingCriterion::LabelModel::input],
            labels: ::Array[String],
            model: String,
            name: String,
            passing_labels: ::Array[String],
            type: :label_model
          }

        class LabelModel < OpenAI::Internal::Type::BaseModel
          attr_accessor input: ::Array[OpenAI::EvalCreateParams::TestingCriterion::LabelModel::input]

          attr_accessor labels: ::Array[String]

          attr_accessor model: String

          attr_accessor name: String

          attr_accessor passing_labels: ::Array[String]

          attr_accessor type: :label_model

          def initialize: (
            input: ::Array[OpenAI::EvalCreateParams::TestingCriterion::LabelModel::input],
            labels: ::Array[String],
            model: String,
            name: String,
            passing_labels: ::Array[String],
            ?type: :label_model
          ) -> void

          type input =
            OpenAI::EvalCreateParams::TestingCriterion::LabelModel::Input::SimpleInputMessage
            | OpenAI::EvalCreateParams::TestingCriterion::LabelModel::Input::EvalItem

          module Input
            extend OpenAI::Internal::Type::Union

            type simple_input_message = { content: String, role: String }

            class SimpleInputMessage < OpenAI::Internal::Type::BaseModel
              attr_accessor content: String

              attr_accessor role: String

              def initialize: (content: String, role: String) -> void
            end

            type eval_item =
              {
                content: OpenAI::EvalCreateParams::TestingCriterion::LabelModel::Input::EvalItem::content,
                role: OpenAI::EvalCreateParams::TestingCriterion::LabelModel::Input::EvalItem::role,
                type: OpenAI::EvalCreateParams::TestingCriterion::LabelModel::Input::EvalItem::type_
              }

            class EvalItem < OpenAI::Internal::Type::BaseModel
              attr_accessor content: OpenAI::EvalCreateParams::TestingCriterion::LabelModel::Input::EvalItem::content

              attr_accessor role: OpenAI::EvalCreateParams::TestingCriterion::LabelModel::Input::EvalItem::role

              attr_reader type: OpenAI::EvalCreateParams::TestingCriterion::LabelModel::Input::EvalItem::type_?

              def type=: (
                OpenAI::EvalCreateParams::TestingCriterion::LabelModel::Input::EvalItem::type_
              ) -> OpenAI::EvalCreateParams::TestingCriterion::LabelModel::Input::EvalItem::type_

              def initialize: (
                content: OpenAI::EvalCreateParams::TestingCriterion::LabelModel::Input::EvalItem::content,
                role: OpenAI::EvalCreateParams::TestingCriterion::LabelModel::Input::EvalItem::role,
                ?type: OpenAI::EvalCreateParams::TestingCriterion::LabelModel::Input::EvalItem::type_
              ) -> void

              type content =
                String
                | OpenAI::Responses::ResponseInputText
                | OpenAI::EvalCreateParams::TestingCriterion::LabelModel::Input::EvalItem::Content::OutputText

              module Content
                extend OpenAI::Internal::Type::Union

                type output_text = { text: String, type: :output_text }

                class OutputText < OpenAI::Internal::Type::BaseModel
                  attr_accessor text: String

                  attr_accessor type: :output_text

                  def initialize: (text: String, ?type: :output_text) -> void
                end

                def self?.variants: -> ::Array[OpenAI::EvalCreateParams::TestingCriterion::LabelModel::Input::EvalItem::content]
              end

              type role = :user | :assistant | :system | :developer

              module Role
                extend OpenAI::Internal::Type::Enum

                USER: :user
                ASSISTANT: :assistant
                SYSTEM: :system
                DEVELOPER: :developer

                def self?.values: -> ::Array[OpenAI::EvalCreateParams::TestingCriterion::LabelModel::Input::EvalItem::role]
              end

              type type_ = :message

              module Type
                extend OpenAI::Internal::Type::Enum

                MESSAGE: :message

                def self?.values: -> ::Array[OpenAI::EvalCreateParams::TestingCriterion::LabelModel::Input::EvalItem::type_]
              end
            end

            def self?.variants: -> ::Array[OpenAI::EvalCreateParams::TestingCriterion::LabelModel::input]
          end
        end

        type python =
          {
            name: String,
            source: String,
            type: :python,
            image_tag: String,
            pass_threshold: Float
          }

        class Python < OpenAI::Internal::Type::BaseModel
          attr_accessor name: String

          attr_accessor source: String

          attr_accessor type: :python

          attr_reader image_tag: String?

          def image_tag=: (String) -> String

          attr_reader pass_threshold: Float?

          def pass_threshold=: (Float) -> Float

          def initialize: (
            name: String,
            source: String,
            ?image_tag: String,
            ?pass_threshold: Float,
            ?type: :python
          ) -> void
        end

        type score_model =
          {
            input: ::Array[OpenAI::EvalCreateParams::TestingCriterion::ScoreModel::Input],
            model: String,
            name: String,
            type: :score_model,
            pass_threshold: Float,
            range: ::Array[Float],
            sampling_params: top
          }

        class ScoreModel < OpenAI::Internal::Type::BaseModel
          attr_accessor input: ::Array[OpenAI::EvalCreateParams::TestingCriterion::ScoreModel::Input]

          attr_accessor model: String

          attr_accessor name: String

          attr_accessor type: :score_model

          attr_reader pass_threshold: Float?

          def pass_threshold=: (Float) -> Float

          attr_reader range: ::Array[Float]?

          def range=: (::Array[Float]) -> ::Array[Float]

          attr_reader sampling_params: top?

          def sampling_params=: (top) -> top

          def initialize: (
            input: ::Array[OpenAI::EvalCreateParams::TestingCriterion::ScoreModel::Input],
            model: String,
            name: String,
            ?pass_threshold: Float,
            ?range: ::Array[Float],
            ?sampling_params: top,
            ?type: :score_model
          ) -> void

          type input =
            {
              content: OpenAI::EvalCreateParams::TestingCriterion::ScoreModel::Input::content,
              role: OpenAI::EvalCreateParams::TestingCriterion::ScoreModel::Input::role,
              type: OpenAI::EvalCreateParams::TestingCriterion::ScoreModel::Input::type_
            }

          class Input < OpenAI::Internal::Type::BaseModel
            attr_accessor content: OpenAI::EvalCreateParams::TestingCriterion::ScoreModel::Input::content

            attr_accessor role: OpenAI::EvalCreateParams::TestingCriterion::ScoreModel::Input::role

            attr_reader type: OpenAI::EvalCreateParams::TestingCriterion::ScoreModel::Input::type_?

            def type=: (
              OpenAI::EvalCreateParams::TestingCriterion::ScoreModel::Input::type_
            ) -> OpenAI::EvalCreateParams::TestingCriterion::ScoreModel::Input::type_

            def initialize: (
              content: OpenAI::EvalCreateParams::TestingCriterion::ScoreModel::Input::content,
              role: OpenAI::EvalCreateParams::TestingCriterion::ScoreModel::Input::role,
              ?type: OpenAI::EvalCreateParams::TestingCriterion::ScoreModel::Input::type_
            ) -> void

            type content =
              String
              | OpenAI::Responses::ResponseInputText
              | OpenAI::EvalCreateParams::TestingCriterion::ScoreModel::Input::Content::OutputText

            module Content
              extend OpenAI::Internal::Type::Union

              type output_text = { text: String, type: :output_text }

              class OutputText < OpenAI::Internal::Type::BaseModel
                attr_accessor text: String

                attr_accessor type: :output_text

                def initialize: (text: String, ?type: :output_text) -> void
              end

              def self?.variants: -> ::Array[OpenAI::EvalCreateParams::TestingCriterion::ScoreModel::Input::content]
            end

            type role = :user | :assistant | :system | :developer

            module Role
              extend OpenAI::Internal::Type::Enum

              USER: :user
              ASSISTANT: :assistant
              SYSTEM: :system
              DEVELOPER: :developer

              def self?.values: -> ::Array[OpenAI::EvalCreateParams::TestingCriterion::ScoreModel::Input::role]
            end

            type type_ = :message

            module Type
              extend OpenAI::Internal::Type::Enum

              MESSAGE: :message

              def self?.values: -> ::Array[OpenAI::EvalCreateParams::TestingCriterion::ScoreModel::Input::type_]
            end
          end
        end

        def self?.variants: -> ::Array[OpenAI::EvalCreateParams::testing_criterion]
      end
    end
  end
end
