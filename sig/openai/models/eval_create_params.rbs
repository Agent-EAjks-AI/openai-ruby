module OpenAI
  module Models
    type eval_create_params =
      {
        data_source_config: OpenAI::Models::EvalCreateParams::data_source_config,
        testing_criteria: ::Array[OpenAI::EvalCreateParams::testing_criterion],
        metadata: OpenAI::Models::metadata?,
        name: String
      }
      & OpenAI::Internal::Type::request_parameters

    class EvalCreateParams < OpenAI::Internal::Type::BaseModel
      extend OpenAI::Internal::Type::RequestParameters::Converter
      include OpenAI::Internal::Type::RequestParameters

      attr_accessor data_source_config: OpenAI::Models::EvalCreateParams::data_source_config

      attr_accessor testing_criteria: ::Array[OpenAI::EvalCreateParams::testing_criterion]

      attr_accessor metadata: OpenAI::Models::metadata?

      attr_reader name: String?

      def name=: (String) -> String

      def initialize: (
        data_source_config: OpenAI::Models::EvalCreateParams::data_source_config,
        testing_criteria: ::Array[OpenAI::EvalCreateParams::testing_criterion],
        ?metadata: OpenAI::Models::metadata?,
        ?name: String,
        ?request_options: OpenAI::request_opts
      ) -> void

      type data_source_config =
        OpenAI::EvalCreateParams::DataSourceConfig::Custom
        | OpenAI::EvalCreateParams::DataSourceConfig::Logs
        | OpenAI::EvalCreateParams::DataSourceConfig::StoredCompletions

      module DataSourceConfig
        extend OpenAI::Internal::Type::Union

        type custom =
          {
            item_schema: ::Hash[Symbol, top],
            type: :custom,
            include_sample_schema: bool
          }

        class Custom < OpenAI::Internal::Type::BaseModel
          attr_accessor item_schema: ::Hash[Symbol, top]

          attr_accessor type: :custom

          attr_reader include_sample_schema: bool?

          def include_sample_schema=: (bool) -> bool

          def initialize: (
            item_schema: ::Hash[Symbol, top],
            ?include_sample_schema: bool,
            ?type: :custom
          ) -> void
        end

        type logs = { type: :logs, metadata: ::Hash[Symbol, top] }

        class Logs < OpenAI::Internal::Type::BaseModel
          attr_accessor type: :logs

          attr_reader metadata: ::Hash[Symbol, top]?

          def metadata=: (::Hash[Symbol, top]) -> ::Hash[Symbol, top]

          def initialize: (?metadata: ::Hash[Symbol, top], ?type: :logs) -> void
        end

        type stored_completions =
          { type: :"stored-completions", metadata: ::Hash[Symbol, top] }

        class StoredCompletions < OpenAI::Internal::Type::BaseModel
          attr_accessor type: :"stored-completions"

          attr_reader metadata: ::Hash[Symbol, top]?

          def metadata=: (::Hash[Symbol, top]) -> ::Hash[Symbol, top]

          def initialize: (
            ?metadata: ::Hash[Symbol, top],
            ?type: :"stored-completions"
          ) -> void
        end

        def self?.variants: -> ::Array[OpenAI::Models::EvalCreateParams::data_source_config]
      end

      type testing_criterion =
        OpenAI::EvalCreateParams::TestingCriterion::LabelModel
        | OpenAI::Graders::StringCheckGrader
        | OpenAI::EvalCreateParams::TestingCriterion::TextSimilarity
        | OpenAI::EvalCreateParams::TestingCriterion::Python
        | OpenAI::EvalCreateParams::TestingCriterion::ScoreModel

      module TestingCriterion
        extend OpenAI::Internal::Type::Union

        type label_model =
          {
            input: ::Array[OpenAI::EvalCreateParams::TestingCriterion::LabelModel::input],
            labels: ::Array[String],
            model: String,
            name: String,
            passing_labels: ::Array[String],
            type: :label_model
          }

        class LabelModel < OpenAI::Internal::Type::BaseModel
          attr_accessor input: ::Array[OpenAI::EvalCreateParams::TestingCriterion::LabelModel::input]

          attr_accessor labels: ::Array[String]

          attr_accessor model: String

          attr_accessor name: String

          attr_accessor passing_labels: ::Array[String]

          attr_accessor type: :label_model

          def initialize: (
            input: ::Array[OpenAI::EvalCreateParams::TestingCriterion::LabelModel::input],
            labels: ::Array[String],
            model: String,
            name: String,
            passing_labels: ::Array[String],
            ?type: :label_model
          ) -> void

          type input =
            OpenAI::EvalCreateParams::TestingCriterion::LabelModel::Input::SimpleInputMessage
            | OpenAI::EvalItem

          module Input
            extend OpenAI::Internal::Type::Union

            type simple_input_message = { content: String, role: String }

            class SimpleInputMessage < OpenAI::Internal::Type::BaseModel
              attr_accessor content: String

              attr_accessor role: String

              def initialize: (content: String, role: String) -> void
            end

            def self?.variants: -> ::Array[OpenAI::EvalCreateParams::TestingCriterion::LabelModel::input]
          end
        end

        type text_similarity = { pass_threshold: Float }

        class TextSimilarity < OpenAI::Models::Graders::TextSimilarityGrader
          def pass_threshold: -> Float

          def pass_threshold=: (Float _) -> Float

          def initialize: (pass_threshold: Float) -> void
        end

        type python = { pass_threshold: Float }

        class Python < OpenAI::Models::Graders::PythonGrader
          def pass_threshold: -> Float?

          def pass_threshold=: (Float _) -> Float

          def initialize: (?pass_threshold: Float) -> void
        end

        type score_model = { pass_threshold: Float }

        class ScoreModel < OpenAI::Models::Graders::ScoreModelGrader
          def pass_threshold: -> Float?

          def pass_threshold=: (Float _) -> Float

          def initialize: (?pass_threshold: Float) -> void
        end

        def self?.variants: -> ::Array[OpenAI::EvalCreateParams::testing_criterion]
      end
    end
  end
end
